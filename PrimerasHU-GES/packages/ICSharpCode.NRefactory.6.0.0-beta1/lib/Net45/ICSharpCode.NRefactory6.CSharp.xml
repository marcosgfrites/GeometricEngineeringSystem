<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICSharpCode.NRefactory6.CSharp</name>
    </assembly>
    <members>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Completion.ICompletionDataFactory.CreateEnumMemberCompletionData(ICSharpCode.NRefactory6.CSharp.Completion.ICompletionKeyHandler,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IFieldSymbol)">
            <summary>
            Creates enum member completion data. 
            Form: Type.Member
            Used for generating enum members Foo.A, Foo.B where the enum 'Foo' is valid.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Completion.ICompletionDataFactory.CreateNewMethodDelegate(ICSharpCode.NRefactory6.CSharp.Completion.ICompletionKeyHandler,Microsoft.CodeAnalysis.ITypeSymbol,System.String,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates the event creation completion data.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.ParameterHintingResult.StartOffset">
            <summary>
            Gets the start offset of the parameter expression node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.Completion.IParameterHintingData">
            <summary>
            Provides intellisense information for a collection of parametrized members.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.IParameterHintingData.Symbol">
            <summary>
            Gets the symbol for which the parameter should be created.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo">
            <summary>
            Provides information about what triggered completion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo.CompletionTriggerReason">
            <summary>
            Provides the reason that completion was triggered.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo.TriggerCharacter">
            <summary>
            If the <see cref="P:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo.CompletionTriggerReason"/> was <see
            cref="F:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerReason.CharTyped"/> then this was the character that was
            typed or deleted by backspace.  Otherwise it is null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo.IsAugment">
            <summary>
            Returns true if the reason completion was triggered was to augment an existing list of
            completion items.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo.IsDebugger">
            <summary>
             Returns true if completion was triggered by the debugger.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Completion.CompletionTriggerInfo.IsImmediateWindow">
            <summary>
            Return true if completion is running in the Immediate Window.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Completion.ICompletionKeyHandler.IsFilterCharacter(ICSharpCode.NRefactory6.CSharp.Completion.ICompletionData,System.Char,System.String)">
            <summary>
            Returns true if the character typed should be used to filter the specified completion
            item.  A character will be checked to see if it should filter an item.  If not, it will be
            checked to see if it should commit that item.  If it does neither, then completion will
            be dismissed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Completion.ICompletionKeyHandler.IsCommitCharacter(ICSharpCode.NRefactory6.CSharp.Completion.ICompletionData,System.Char,System.String)">
            <summary>
            Returns true if the character is one that can commit the specified completion item. A
            character will be checked to see if it should filter an item.  If not, it will be checked
            to see if it should commit that item.  If it does neither, then completion will be
            dismissed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Completion.ICompletionKeyHandler.SendEnterThroughToEditor(ICSharpCode.NRefactory6.CSharp.Completion.ICompletionData,System.String)">
            <summary>
            Returns true if the enter key that was typed should also be sent through to the editor
            after committing the provided completion item.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine">
            <summary>
                Represents a decorator of an IStateMachineIndentEngine instance that provides
                logic for reseting and updating the engine on text changed events.
            </summary>
            <remarks>
                The decorator is based on periodical caching of the engine's state and
                delegating all logic behind indentation to the currently active engine.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.#ctor(ICSharpCode.NRefactory6.CSharp.IStateMachineIndentEngine,System.Int32)">
            <summary>
                Creates a new CacheIndentEngine instance.
            </summary>
            <param name="decoratedEngine">
                An instance of <see cref="T:ICSharpCode.NRefactory6.CSharp.IStateMachineIndentEngine"/> to which the
                logic for indentation will be delegated.
            </param>
            <param name="cacheRate">
                The number of chars between caching.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.#ctor(ICSharpCode.NRefactory6.CSharp.CacheIndentEngine)">
            <summary>
                Creates a new CacheIndentEngine instance from the given prototype.
            </summary>
            <param name="prototype">
                A CacheIndentEngine instance.
            </param>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.ThisLineIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.NextLineIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.CurrentIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.NeedsReindent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.Offset">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.EnableCustomIndentLevels">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.Push(System.Char)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.Reset">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.ResetEngineToPosition(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Resets the engine to offset. Clears all cached engines after the given offset.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.Update(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <inheritdoc />
            <remarks>
                If the <paramref name="position"/> is negative, the engine will
                update to: document.TextLength + (offset % document.TextLength+1)
                Otherwise it will update to: offset % document.TextLength+1
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.Clone">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CacheIndentEngine.ICSharpCode#NRefactory6#CSharp#IDocumentIndentEngine#Clone">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine">
            <summary>
                Indentation engine based on a state machine.
                Supports only pushing new chars to the end.
            </summary>
            <remarks>
                Represents the context for transitions between <see cref="T:ICSharpCode.NRefactory6.CSharp.IndentState"/>.
                Delegates the responsibility for pushing a new char to the current 
                state and changes between states depending on the pushed chars.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.options">
            <summary>
                Formatting options.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.newLineChar">
            <summary>
                Represents the new line character.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.currentState">
            <summary>
                The current indentation state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.conditionalSymbols">
            <summary>
                Stores conditional symbols of #define directives.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.customConditionalSymbols">
            <summary>
                Stores custom conditional symbols.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.ifDirectiveEvalResults">
            <summary>
                Stores the results of evaluations of the preprocessor if/elif directives 
                in the current block (between #if and #endif).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.ifDirectiveIndents">
            <summary>
                Stores the indentation levels of the if directives in the current block.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.wordToken">
            <summary>
                Stores the last sequence of characters that can form a
                valid keyword or variable name.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.previousKeyword">
            <summary>
                Stores the previous sequence of chars that formed a
                valid keyword or variable name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.ThisLineIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.NextLineIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.CurrentIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.NeedsReindent">
            <inheritdoc />
            <remarks>
                This is set depending on the current <see cref="T:Microsoft.CodeAnalysis.Location"/> and
                can change its value until the <see cref="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.newLineChar"/> char is
                pushed. If this is true, that doesn't necessarily mean that the
                current line has an incorrect indent (this can be determined
                only at the end of the current line).
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.Offset">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.EnableCustomIndentLevels">
            <inheritdoc />
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.offset">
            <summary>
               Represents the number of pushed chars.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.line">
            <summary>
               The current line number.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.column">
            <summary>
               The current column number.
            </summary>
            <remarks>
               One char can take up multiple columns (e.g. \t).
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.isLineStart">
            <summary>
               True if <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> is true for all
               chars at the current line.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.isLineStartBeforeWordToken">
            <summary>
               True if <see cref="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.isLineStart"/> was true before the current
               <see cref="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.wordToken"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.currentChar">
            <summary>
               Current char that's being pushed.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.previousChar">
            <summary>
               Last non-whitespace char that has been pushed.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.previousNewline">
            <summary>
               Previous new line char
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.currentIndent">
            <summary>
               Current indent level on this line.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.lineBeganInsideVerbatimString">
            <summary>
                True if this line began in <see cref="T:ICSharpCode.NRefactory6.CSharp.VerbatimStringState"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.lineBeganInsideMultiLineComment">
            <summary>
                True if this line began in <see cref="T:ICSharpCode.NRefactory6.CSharp.MultiLineCommentState"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.#ctor(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
                Creates a new CSharpIndentEngine instance.
            </summary>
            <param name="document">
                An instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> which is being parsed.
            </param>
            <param name="formattingOptions">
                C# formatting options.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.#ctor(ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine)">
            <summary>
                Creates a new CSharpIndentEngine instance from the given prototype.
            </summary>
            <param name="prototype">
                An CSharpIndentEngine instance.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.ICSharpCode#NRefactory6#CSharp#IDocumentIndentEngine#Clone">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.Push(System.Char)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.Reset">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.Update(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.DefineSymbol(System.String)">
            <summary>
            Defines the conditional symbol.
            </summary>
            <param name="defineSymbol">The symbol to define.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.RemoveSymbol(System.String)">
            <summary>
            Removes the symbol.
            </summary>
            <param name="undefineSymbol">The symbol to undefine.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine">
            <summary>
                The base interface for all indent engines.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.ThisLineIndent">
            <summary>
                The indentation string of the current line.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.NextLineIndent">
            <summary>
                The indentation string of the next line.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.CurrentIndent">
            <summary>
                The indent string on the beginning of the current line.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.NeedsReindent">
            <summary>
                True if the current line needs to be reindented.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.Offset">
            <summary>
                The current offset of the engine.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.EnableCustomIndentLevels">
            <summary>
                If this is true, the engine should try to adjust its indent 
                levels to manual user's corrections, even if they are wrong.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.Push(System.Char)">
            <summary>
                Pushes a new char into the engine which calculates the new
                indentation levels.
            </summary>
            <param name="ch">
                A new character.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.Reset">
            <summary>
                Resets the engine.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.Update(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
                Updates the engine to the given offset.
            </summary>
            <param name="offset">
                Valid offset in <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IDocumentIndentEngine.Clone">
            <summary>
                Clones the engine and preserves the current state.
            </summary>
            <returns>
                An indentical clone which can operate without interference
                with this engine.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.IndentState">
            <summary>
                The base class for all indentation states. 
                Each state defines the logic for indentation based on chars that
                are pushed to it.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.IndentState.Engine">
            <summary>
                The indentation engine using this state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.IndentState.Parent">
            <summary>
                The parent state. 
                This state can use the indentation levels of its parent.
                When this state exits, the engine returns to the parent.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.IndentState.ThisLineIndent">
            <summary>
                The indentation of the current line.
                This is set when the state is created and will be changed to
                <see cref="F:ICSharpCode.NRefactory6.CSharp.IndentState.NextLineIndent"/> when the <see cref="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.newLineChar"/> 
                is pushed.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.IndentState.NextLineIndent">
            <summary>
                The indentation of the next line.
                This is set when the state is created and can change depending
                on the pushed chars.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.#ctor(ICSharpCode.NRefactory6.CSharp.IndentState,ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine)">
            <summary>
                Creates a new indentation state that is a copy of the given
                prototype.
            </summary>
            <param name="prototype">
                The prototype state.
            </param>
            <param name="engine">
                The engine of the new state.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.InitializeState">
            <summary>
                Initializes the state:
                  - sets the default indentation levels.
            </summary>
            <remarks>
                Each state can override this method if it needs a different
                logic for setting up the default indentations.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.OnExit">
            <summary>
                Actions performed when this state exits.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.ChangeState``1">
            <summary>
                Changes the current state of the <see cref="T:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine"/> using the current
                state as the parent for the new one.
            </summary>
            <typeparam name="T">
                The type of the new state. Must be assignable from <see cref="T:ICSharpCode.NRefactory6.CSharp.IndentState"/>.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.ExitState">
            <summary>
                Exits this state by setting the current state of the
                <see cref="T:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine"/> to this state's parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.Push(System.Char)">
            <summary>
                Common logic behind the push method.
                Each state can override this method and implement its own logic.
            </summary>
            <param name="ch">
                The current character that's being pushed.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.CheckKeyword(System.String)">
            <summary>
                When derived, checks if the given sequence of chars form
                a valid keyword or variable name, depending on the state.
            </summary>
            <param name="keyword">
                A possible keyword.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.IndentState.CheckKeywordOnPush(System.String)">
            <summary>
                When derived, checks if the given sequence of chars form
                a valid keyword or variable name, depending on the state.
            </summary>
            <param name="keyword">
                A possible keyword.
            </param>
            <remarks>
                This method should be called from <see cref="M:ICSharpCode.NRefactory6.CSharp.IndentState.Push(System.Char)"/>.
                It is left to derived classes to call this method because of
                performance issues.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.NullState">
            <summary>
                Null state.
            </summary>
            <remarks>
                Doesn't define any transitions to new states.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.BracketsBodyBaseState">
            <summary>
                The base for all brackets body states.
            </summary>
            <remarks>
                Represents a block of code between a pair of brackets.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.BracketsBodyBaseState.ClosedBracket">
            <summary>
                When derived in a concrete bracket body state, represents
                the closed bracket character pair.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.BracesBodyState">
            <summary>
                Braces body state.
            </summary>
            <remarks>
                Represents a block of code between { and }.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CurrentBody">
            <summary>
                Type of the current block body.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.NextBody">
            <summary>
                Type of the next block body.
                Same as <see cref="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CurrentBody"/> if none of the
                <see cref="T:ICSharpCode.NRefactory6.CSharp.BracesBodyState.Body"/> keywords have been read.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CurrentStatement">
            <summary>
                Type of the current statement.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.NestedIfStatementLevels">
            <summary>
               Contains indent levels of nested if statements.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.LastBlockIndent">
            <summary>
               Contains the indent level of the last statement or body keyword.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.IsRightHandExpression">
            <summary>
                True if the engine is on the right side of the equal operator '='.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.IsEqualCharPushed">
            <summary>
                True if the '=' char has been pushed and it's not
                a part of a relational operator (&gt;=, &lt;=, !=, ==).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.PreviousLineIndent">
            <summary>
                The indentation of the previous line.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.IsMemberReferenceDotHandled">
            <summary>
                True if the dot member (e.g. method invocation) indentation has
                been handled in the current statement.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.BracesBodyState.OnStatementExit">
            <summary>
                Actions performed when the current statement exits.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.BracesBodyState.Body">
            <summary>
                Types of braces bodies.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.BracesBodyState.Statement">
            <summary>
                Types of statements.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CheckKeywordOnPush(System.String)">
            <summary>
                Checks if the given string is a keyword and sets the
                <see cref="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.NextBody"/> and the <see cref="P:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CurrentStatement"/>
                variables appropriately.
            </summary>
            <param name="keyword">
                A possible keyword.
            </param>
            <remarks>
                This method is called from <see cref="M:ICSharpCode.NRefactory6.CSharp.BracesBodyState.Push(System.Char)"/>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CheckKeyword(System.String)">
            <summary>
                Checks if the given string is a keyword and sets the
                <see cref="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.NextBody"/> and the <see cref="P:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CurrentStatement"/>
                variables appropriately.
            </summary>
            <param name="keyword">
                A possible keyword.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.BracesBodyState.AddIndentation(ICSharpCode.NRefactory6.CSharp.BracesBodyState.Body)">
            <summary>
                Pushes a new level of indentation depending on the given
                <paramref name="body"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.BracesBodyState.extractBody(ICSharpCode.NRefactory6.CSharp.IndentState)">
            <summary>
                Extracts the <see cref="F:ICSharpCode.NRefactory6.CSharp.BracesBodyState.CurrentBody"/> from the given state.
            </summary>
            <returns>
                The correct <see cref="T:ICSharpCode.NRefactory6.CSharp.BracesBodyState.Body"/> type for this state.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.GlobalBodyState">
            <summary>
                Global body state.
            </summary>
            <remarks>
                Represents the global space of the program.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.SwitchCaseState">
            <summary>
                Switch-case statement state.
            </summary>
            <remarks>
                Represents the block of code in one switch case (including default).
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ParenthesesBodyState">
            <summary>
                Parentheses body state.
            </summary>
            <remarks>
                Represents a block of code between ( and ).
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.ParenthesesBodyState.IsSomethingPushed">
            <summary>
                True if any char has been pushed.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.SquareBracketsBodyState">
            <summary>
                Square brackets body state.
            </summary>
            <remarks>
                Represents a block of code between [ and ].
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.SquareBracketsBodyState.IsSomethingPushed">
            <summary>
                True if any char has been pushed.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.PreProcessorState">
            <summary>
                PreProcessor directive state.
            </summary>
            <remarks>
                Activated when the '#' char is pushed and the 
                <see cref="F:ICSharpCode.NRefactory6.CSharp.CSharpIndentEngine.isLineStart"/> is true.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.PreProcessorState.DirectiveType">
            <summary>
                The type of the preprocessor directive.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.PreProcessorState.DirectiveStatement">
            <summary>
                If <see cref="F:ICSharpCode.NRefactory6.CSharp.PreProcessorState.DirectiveType"/> is set (not equal to 'None'), this
                stores the expression of the directive.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.PreProcessorState.PreProcessorDirective">
            <summary>
                Types of preprocessor directives.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.PreProcessorCommentState">
            <summary>
                PreProcessor comment state.
            </summary>
            <remarks>
                Activates when the #if or #elif directive is false and ignores
                all pushed chars until the next '#'.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.LineCommentState">
            <summary>
                Single-line comment state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.LineCommentState.CheckForDocComment">
            <summary>
                It's possible that this should be the DocComment state:
                    check if the first next pushed char is equal to '/'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.DocCommentState">
            <summary>
                XML documentation comment state.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.MultiLineCommentState">
            <summary>
                Multi-line comment state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.MultiLineCommentState.IsAnyCharPushed">
            <summary>
                True if any char has been pushed to this state.
            </summary>
            <remarks>
                Needed to resolve an issue when the first pushed char is '/'.
                The state would falsely exit on this sequence of chars '/*/',
                since it only checks if the last two chars are '/' and '*'.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.StringLiteralState">
            <summary>
                StringLiteral state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.StringLiteralState.IsEscaped">
            <summary>
                True if the next char is escaped with '\'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.VerbatimStringState">
            <summary>
                Verbatim string state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.VerbatimStringState.IsEscaped">
            <summary>
                True if there is an odd number of '"' in a row.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.CharacterState">
            <summary>
                Character state.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.CharacterState.IsEscaped">
            <summary>
                True if the next char is escaped with '\'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ITextPasteHandler">
            <summary>
            The text paste handler can do formattings to a text that is about to be pasted
            into the text document.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ITextPasteHandler.FormatPlainText(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,System.String,System.Byte[])">
            <summary>
            Formats plain text that is inserted at a specified offset.
            </summary>
            <returns>
            The text that will get inserted at that position.
            </returns>
            <param name="offset">The offset where the text will be inserted.</param>
            <param name="text">The text to be inserted.</param>
            <param name="copyData">Additional data in case the text was copied from a Mono.TextEditor.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ITextPasteHandler.GetCopyData(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets the copy data for a specific segment inside the document. This can contain additional information.
            </summary>
            <param name="segment">The text segment that is about to be copied.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.NullIStateMachineIndentEngine">
            <summary>
            An empty IStateMachineIndentEngine implementation that does nothing.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.NullIStateMachineIndentEngine.EnableCustomIndentLevels">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine">
            <summary>
                Represents a decorator of an IStateMachineIndentEngine instance
                that provides logic for text paste events.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.engine">
            <summary>
                An instance of IStateMachineIndentEngine which handles
                the indentation logic.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.options">
            <summary>
                Text editor options.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.#ctor(ICSharpCode.NRefactory6.CSharp.IStateMachineIndentEngine,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
                Creates a new TextPasteIndentEngine instance.
            </summary>
            <param name="decoratedEngine">
                An instance of <see cref="T:ICSharpCode.NRefactory6.CSharp.IStateMachineIndentEngine"/> to which the
                logic for indentation will be delegated.
            </param>
            <param name = "options"></param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.ICSharpCode#NRefactory6#CSharp#ITextPasteHandler#FormatPlainText(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,System.String,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.ICSharpCode#NRefactory6#CSharp#ITextPasteHandler#GetCopyData(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan)">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.ThisLineIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.NextLineIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.CurrentIndent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.NeedsReindent">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.Offset">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.EnableCustomIndentLevels">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.Push(System.Char)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.Reset">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteIndentEngine.Update(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.PasteStrategy">
            <summary>
                Types of text-paste strategies.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils">
            <summary>
                Defines some helper methods for dealing with text-paste events.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.Strategies">
            <summary>
                Collection of text-paste strategies.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.IPasteStrategy">
            <summary>
                The interface for a text-paste strategy.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.IPasteStrategy.Encode(System.String)">
            <summary>
                Formats the given text according with this strategy rules.
            </summary>
            <param name="text">
               The text to format.
            </param>
            <returns>
                Formatted text.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.IPasteStrategy.Decode(System.String)">
            <summary>
                Converts text formatted according with this strategy rules
                to its original form.
            </summary>
            <param name="text">
                Formatted text to convert.
            </param>
            <returns>
                Original form of the given formatted text.
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.IPasteStrategy.Type">
            <summary>
                Type of this strategy.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.TextPasteStrategies">
            <summary>
                Wrapper that discovers all defined text-paste strategies and defines a way
                to easily access them through their <see cref="T:ICSharpCode.NRefactory6.CSharp.PasteStrategy"/> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.TextPasteStrategies.strategies">
            <summary>
                Collection of discovered text-paste strategies.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.TextPasteStrategies.#ctor">
            <summary>
                Uses reflection to find all types derived from <see cref="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.IPasteStrategy"/>
                and adds an instance of each strategy to <see cref="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.TextPasteStrategies.strategies"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.TextPasteStrategies.Item(ICSharpCode.NRefactory6.CSharp.PasteStrategy)">
            <summary>
                Checks if there is a strategy of the given type and returns it.
            </summary>
            <param name="strategy">
                Type of the strategy instance.
            </param>
            <returns>
                A strategy instance of the requested type,
                or <see cref="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.DefaultStrategy"/> if it wasn't found.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.PlainTextPasteStrategy">
            <summary>
                Doesn't do any formatting. Serves as the default strategy.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.PlainTextPasteStrategy.Encode(System.String)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.PlainTextPasteStrategy.Decode(System.String)">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.PlainTextPasteStrategy.Type">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralPasteStrategy">
            <summary>
                Escapes chars in the given text so that they don't
                break a valid string literal.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralPasteStrategy.Encode(System.String)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralPasteStrategy.ConvertChar(System.Char)">
            <summary>
            Gets the escape sequence for the specified character.
            </summary>
            <remarks>This method does not convert ' or ".</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralPasteStrategy.ConvertString(System.String)">
            <summary>
            Converts special characters to escape sequences within the given string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralPasteStrategy.Decode(System.String)">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralPasteStrategy.Type">
            <inheritdoc />
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.VerbatimStringPasteStrategy">
            <summary>
                Escapes chars in the given text so that they don't
                break a valid verbatim string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.VerbatimStringPasteStrategy.Encode(System.String)">
            <inheritdoc />
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.VerbatimStringPasteStrategy.Decode(System.String)">
            <inheritdoc />
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.VerbatimStringPasteStrategy.Type">
            <inheritdoc />
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.DefaultStrategy">
            <summary>
                The default text-paste strategy.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.StringLiteralStrategy">
            <summary>
                String literal text-paste strategy.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.TextPasteUtils.VerbatimStringStrategy">
            <summary>
                Verbatim string text-paste strategy.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.FormattingOptionsFactory">
            <summary>
            The formatting options factory creates pre defined formatting option styles.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.FormattingOptionsFactory.CreateMono">
            <summary>
            Creates mono indent style CSharpFormatting options.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.FormattingOptionsFactory.CreateSharpDevelop">
            <summary>
            Creates sharp develop indent style CSharpFormatting options.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICSharpCode.NRefactory6.CSharp.FormattingOptionsFactory.CreateKRStyle" -->
        <member name="M:ICSharpCode.NRefactory6.CSharp.FormattingOptionsFactory.CreateAllman">
            <summary>
            Creates allman indent style CSharpFormatting options used in Visual Studio.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.Analysis.SemanticHighlightingVisitor`1">
            <summary>
            C# Semantic highlighter.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Analysis.SemanticHighlightingVisitor`1.parameterModifierColor">
            <summary>
            Used for 'in' modifiers on type parameters.
            </summary>
            <remarks>
            'in' may have a different color when used with 'foreach'.
            'out' is not colored by semantic highlighting, as syntax highlighting can already detect it as a parameter modifier.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Analysis.SemanticHighlightingVisitor`1.inactiveCodeColor">
            <summary>
            Used for inactive code (excluded by preprocessor or ConditionalAttribute)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CompletionContext.AdditionalContextHandlers">
            <summary>
            Adds completion context handlers to the given context.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.CompletionContext.UseDefaultContextHandlers">
            <summary>
            If false no default handlers will be used and only the AdditionalContextHandlers will run.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.FormattingRangeHelper">
            <summary>
            this help finding a range of tokens to format based on given ending token
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CommonFormattingHelpers.AppendPartialLeadingTriviaText(Microsoft.CodeAnalysis.SyntaxToken,System.Text.StringBuilder,System.Int32)">
            <summary>
            If the token1 is expected to be part of the leading trivia of the token2 then the trivia
            before the token1FullSpanEnd, which the fullspan end of the token1 should be ignored
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatusFlag">
            <summary>
            status code for extract method operations
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatusFlag.Succeeded">
            <summary>
            operation has succeeded
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatusFlag.Suggestion">
            <summary>
            operation has succeeded with a span that is different than original span
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatusFlag.BestEffort">
            <summary>
            operation has failed but can provide some best effort result
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.Extensions.GetTokenWithAnnotaton(ICSharpCode.NRefactory6.CSharp.SemanticDocument,Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            get tokens with given annotation in current document
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.Extensions.ResolveType``1(Microsoft.CodeAnalysis.SemanticModel,``0)">
            <summary>
            resolve the given symbol against compilation this snapshot has
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.Extensions.HasDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            check whether node contains error for itself but not from its child node
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.Succeeded">
            <summary>
            True if the extract method operation succeeded.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.SucceededWithSuggestion">
            <summary>
            True if the extract method operation is possible if the original span is adjusted.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.Document">
            <summary>
            The transformed document that was produced as a result of the extract method operation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.Reasons">
            <summary>
            The reasons why the extract method operation did not succeed.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.MethodDeclarationNode">
            <summary>
            the generated method node that contains the extracted code.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.InvocationNameToken">
            <summary>
            The name token for the invocation node that replaces the extracted code.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ExtractMethodResult.Status">
            <summary>
            public status of result. more fine grained reason why it is failed. 
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ITriviaSavedResult">
            <summary>
            contains information to restore trivia later on to the annotated tree
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ITriviaSavedResult.Root">
            <summary>
            root node of the annotated tree.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ITriviaSavedResult.RestoreTrivia(Microsoft.CodeAnalysis.SyntaxNode,ICSharpCode.NRefactory6.CSharp.ExtractMethod.AnnotationResolver,ICSharpCode.NRefactory6.CSharp.ExtractMethod.TriviaResolver)">
            <summary>
            restore saved trivia to given tree
            </summary>
            <param name="root">root node to the annotated tree</param>
            <param name="annotationResolver">it provides a custom way of resolving annotations to retrieve right tokens to attach trivia</param>
            <param name="triviaResolver">it provides a custom way of creating trivia list between two tokens</param>
            <returns>root node to a trivia restored tree</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ISyntaxTriviaService">
            <summary>
            syntax trivia related services
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.ISyntaxTriviaService.SaveTriviaAroundSelection(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            save trivia around span and let user restore trivia later
            </summary>
            <param name="root">root node of a tree</param>
            <param name="textSpan">selection whose trivia around its edges will be saved</param>
            <returns>object that holds onto enough information to restore trivia later</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.Analyzer.GetFlowAnalysisNodeRange">
            <summary>
            convert text span to node range for the flow analysis API
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.Analyzer.ContainsReturnStatementInSelectedCode(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            check whether selection contains return statement or not
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.Analyzer.CreateFromSymbol(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,ICSharpCode.NRefactory6.CSharp.ExtractMethod.VariableStyle,System.Boolean)">
            <summary>
            create VariableInfo type
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.Analyzer.GetIndexOfVariableInfoToUseAsReturnValue(System.Collections.Generic.IList{ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.VariableInfo})">
            <summary>
            among variables that will be used as parameters at the extracted method, check whether one of the parameter can be used as return
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.Analyzer.GetRangeVariableType(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.IRangeVariableSymbol)">
            <summary>
            get type of the range variable symbol
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.Analyzer.ReadOnlyFieldAllowed">
            <summary>
            check whether the selection is at the placed where read-only field is allowed to be extracted out
            </summary>
            <returns></returns>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.AnalyzerResult.UseInstanceMember">
            <summary>
            used to determine whether static can be used
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.AnalyzerResult.EndOfSelectionReachable">
            <summary>
            used to determine whether "return" statement needs to be inserted
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.AnalyzerResult.SemanticDocument">
            <summary>
            document this result is based on
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.AnalyzerResult.AwaitTaskReturn">
            <summary>
            flag to show whether task return type is due to await
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.AnalyzerResult.ReturnType">
            <summary>
            return type
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.AnalyzerResult.Status">
            <summary>
            analyzer result operation status
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.VariableSymbol">
            <summary>
            temporary symbol until we have a symbol that can hold onto both local and parameter symbol
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.VariableSymbol.OriginalTypeHadAnonymousTypeOrDelegate">
            <summary>
            return true if original type had anonymous type or delegate somewhere in the type
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.ExtractMethod.MethodExtractor.VariableSymbol.OriginalType">
            <summary>
            get the original type with anonymous type removed
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatus.Create``1(ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatus,``0)">
            <summary>
            create operation status with the given data
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ExtractMethod.OperationStatus`1">
            <summary>
            operation status paired with data
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.ExtractMethod.SelectionResult">
            <summary>
            clean up this code when we do selection validator work.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Features.GotoDefinition.GoToDefinitionService.TryNavigateToSymbol">
            <summary>
            Navigate to the first source location of a given symbol.
            bool TryNavigateToSymbol(ISymbol symbol, Project project, bool usePreviewTab = false);
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Features.GotoDefinition.GoToDefinitionService.TryNavigateToSpan">
            <summary>
            Navigates to the given position in the specified document, opening it if necessary.
            bool TryNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan, bool usePreviewTab = false);
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Features.GotoDefinition.GoToDefinitionService.CanNavigateToSpan">
            <summary>
            Determines whether it is possible to navigate to the given position in the specified document.
            bool CanNavigateToSpan(Workspace workspace, DocumentId documentId, TextSpan textSpan);
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Features.GotoDefinition.GoToDefinitionService.TrySymbolNavigationNotify">
            <summary>
            bool TrySymbolNavigationNotify(ISymbol symbol, Solution solution);
            </summary>
            <returns>True if the navigation was handled, indicating that the caller should not 
            perform the navigation.
            
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.AnnotationTable`1">
            <summary>
            An AnnotationTable helps you attach your own annotation types/instances to syntax.  
            
            It maintains a map between your instances and actual SyntaxAnnotation's used to annotate the nodes
            and offers an API that matches the true annotation API on SyntaxNode.
            
            The table controls the lifetime of when you can find and retrieve your annotations. You won't be able to 
            find your annotations via HasAnnotations/GetAnnotations unless you use the same annotation table for these operations
            that you used for the WithAdditionalAnnotations operation.  
            
            Your custom annotations are not serialized with the syntax tree, so they won't move across boundaries unless the 
            same AnnotationTable is available on both ends.
            
            also, note that this table is not thread safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ArgumentSyntaxExtensions.DetermineParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns the parameter to which this argument is passed. If <paramref name="allowParams"/>
            is true, the last parameter will be returned if it is params parameter and the index of
            the specified argument is greater than the number of parameters.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeFixContextExtensions.RegisterFixes(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeAction},Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Use this helper to register multiple fixes (<paramref name="actions"/>) each of which addresses / fixes the same supplied <paramref name="diagnostic"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeFixContextExtensions.RegisterFixes(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Use this helper to register multiple fixes (<paramref name="actions"/>) each of which addresses / fixes the same set of supplied <paramref name="diagnostics"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.CodeGenerationSymbolFactory">
            <summary>
            Generates symbols that describe declarations to be generated.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGenerationSymbolFactory.IsCodeGenerationSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is purely a code generation symbol.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGenerationSymbolFactory.CreatePropertySymbol(System.Collections.Generic.IList{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Boolean)">
            <summary>
            Creates a property symbol that can be used to describe a property declaration.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpUtil.InvertCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Inverts a boolean condition. Note: The condition object can be frozen (from AST) it's cloned internally.
            </summary>
            <param name="condition">The condition to invert.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpUtil.AddParensForUnaryExpressionIfRequired(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            When negating an expression this is required, otherwise you would end up with
            a or b -> !a or b
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpUtil.NegateRelationalOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Get negation of the specified relational operator
            </summary>
            <returns>
            negation of the specified relational operator, or BinaryOperatorType.Any if it's not a relational operator
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpUtil.IsRelationalOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns true, if the specified operator is a relational operator
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CSharpUtil.NegateConditionOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Get negation of the condition operator
            </summary>
            <returns>
            negation of the specified condition operator, or BinaryOperatorType.Any if it's not a condition operator
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.DocumentExtensions.GetSemanticModelForSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            this will return either regular semantic model or speculative semantic based on context. 
            any feature that is involved in typing or run on UI thread should use this to take advantage of speculative semantic model 
            whenever possible automatically.
            
            when using this API, semantic model should only be used to ask node inside of the given span. 
            otherwise, it might throw if semantic model returned by this API is a speculative semantic model.
            
            also, symbols from the semantic model returned by this API might have out of date location information. 
            if exact location (not relative location) is needed from symbol, regular GetSemanticModel should be used.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.DocumentExtensions.GetSemanticModelForNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            this will return either regular semantic model or speculative semantic based on context. 
            any feature that is involved in typing or run on UI thread should use this to take advantage of speculative semantic model 
            whenever possible automatically.
            
            when using this API, semantic model should only be used to ask node inside of the given node except ones that belong to 
            member signature. otherwise, it might throw if semantic model returned by this API is a speculative semantic model.
            
            also, symbols from the semantic model returned by this API might have out of date location information. 
            if exact location (not relative location) is needed from symbol, regular GetSemanticModel should be used.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:ICSharpCode.NRefactory6.CSharp.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:ICSharpCode.NRefactory6.CSharp.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:ICSharpCode.NRefactory6.CSharp.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:ICSharpCode.NRefactory6.CSharp.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExpressionSyntaxExtensions.CastIfPossible(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Int32,Microsoft.CodeAnalysis.SemanticModel,System.Boolean@)">
            <summary>
            Adds to <paramref name="targetType"/> if it does not contain an anonymous
            type and binds to the same type at the given <paramref name="position"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExpressionSyntaxExtensions.IsMemberAccessADynamicInvocation(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Tells if the Member access is the starting part of a Dynamic Invocation
            </summary>
            <param name="memberAccess"></param>
            <param name="semanticModel"></param>
            <returns>Return true, if the member access is the starting point of a Dynamic Invocation</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ExpressionSyntaxExtensions.GetPredefinedKeywordKind(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Returns the predefined keyword kind for a given specialtype.
            </summary>
            <param name="specialType">The specialtype of this type.</param>
            <returns>The keyword kind for a given special type, or SyntaxKind.None if the type name is not a predefined type.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.OperatorPrecedence">
            <summary>
            Operator precedence classes from section 7.3.1 of the C# language specification.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.FindTokenHelper.FindTokenOnRightOfPosition``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.FindTokenHelper.FindTokenOnLeftOfPosition``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.FindTokenHelper.FindSkippedTokenBackward(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.FindTokenHelper.FindSkippedTokenForward(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.Byte*,System.Int32,System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="length">The length of the sequence.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within 'within'.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within name type 'within', with an optional
            qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ISymbolExtensions.IsSymbolAccessible(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within', with an qualifier of
            type "throughTypeOpt". Sets "failedThroughTypeCheck" to true if it failed the "through
            type" check.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.ISymbolExtensions.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a INamedTypeSymbol
            or an IAssemblySymbol.  If 'symbol' is accessed off of an expression then
            'throughTypeOpt' is the type of that expression. This is needed to properly do protected
            access checks. Sets "failedThroughTypeCheck" to true if this protected check failed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Matcher.Repeat``1(ICSharpCode.NRefactory6.CSharp.Matcher{``0})">
            <summary>
            Matcher equivalent to (m*)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Matcher.OneOrMore``1(ICSharpCode.NRefactory6.CSharp.Matcher{``0})">
            <summary>
            Matcher equivalent to (m+)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Matcher.Choice``1(ICSharpCode.NRefactory6.CSharp.Matcher{``0},ICSharpCode.NRefactory6.CSharp.Matcher{``0})">
            <summary>
            Matcher equivalent to (m_1|m_2)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Matcher.Sequence``1(ICSharpCode.NRefactory6.CSharp.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1 ... m_n)
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.Matcher.Single``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Matcher that matches an element if the provide predicate returns true.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.NameGenerator.EnsureUniqueness(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Ensures that any 'names' is unique and does not collide with any other name.  Names that
            are marked as IsFixed can not be touched.  This does mean that if there are two names
            that are the same, and both are fixed that you will end up with non-unique names at the
            end.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.NameGenerator.EnsureUniqueness(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Transforms baseName into a name that does not conflict with any name in 'reservedNames'
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.NRefactory6Host">
            <summary>
            Needs to be implemented from IDE/host side.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SemanticModelExtensions.DecomposeName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax@,System.String@,System.Int32@)">
            <summary>
            Decomposes a name or member access expression into its component parts.
            </summary>
            <param name="expression">The name or member access expression.</param>
            <param name="qualifier">The qualifier (or left-hand-side) of the name expression. This may be null if there is no qualifier.</param>
            <param name="name">The name of the expression.</param>
            <param name="arity">The number of generic type parameters.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SemanticModelExtensions.GenerateNameForArgument(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax)">
            <summary>
            Given an argument node, tries to generate an appropriate name that can be used for that
            argument.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SemanticModelExtensions.GenerateNameForExpression(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean)">
            <summary>
            Given an expression node, tries to generate an appropriate name that can be used for
            that expression. 
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SemanticModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about the parent of a token.
            </summary>
            <param name="semanticModel">The SemanticModel object to get semantic information
            from.</param>
            <param name="token">The token to get semantic information from. This must be part of the
            syntax tree associated with the binding.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SourceTextExtensions.GetLeadingWhitespaceOfLineAtPosition(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Returns the leading whitespace of the line located at the specified position in the given snapshot.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SourceTextExtensions.TryOverlapsHiddenPosition(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Func{System.Int32,System.Threading.CancellationToken,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Same as OverlapsHiddenPosition but doesn't throw on cancellation.  Instead, returns false
            in that case.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.StringExtensions.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.GetEditorBrowsableState(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the EditorBrowsableState of an entity.
            </summary>
            <returns>
            The editor browsable state.
            </returns>
            <param name='symbol'>
            Entity.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.IsEditorBrowsable(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if an entity should be shown in the code completion window. This is the same as:
            <c>GetEditorBrowsableState (entity) != System.ComponentModel.EditorBrowsableState.Never</c>
            </summary>
            <returns>
            <c>true</c> if the entity should be shown; otherwise, <c>false</c>.
            </returns>
            <param name='symbol'>
            The entity.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.IsDesignerBrowsable(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the symbol wasn't tagged with
            [System.ComponentModel.BrowsableAttribute (false)]
            </summary>
            <returns><c>true</c> if is designer browsable the specified symbol; otherwise, <c>false</c>.</returns>
            <param name="symbol">Symbol.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.GetComponentCategory(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the component category.
            [System.ComponentModel.CategoryAttribute (CATEGORY)]
            </summary>
            <param name="symbol">Symbol.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.IsUnsafe(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if this symbol contains anything unsafe within it.  for example
            List&lt;int*[]&gt; is unsafe, as it "int* Foo { get; }"
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.IsInaccessibleLocal(Microsoft.CodeAnalysis.ISymbol,System.Int32)">
            <returns>
            Returns true if symbol is a local variable and its declaring syntax node is 
            after the current position, false otherwise (including for non-local symbols)
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.IsAwaitable(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32)">
            <summary>
            If the <paramref name="symbol"/> is a method symbol, returns True if the method's return type is "awaitable".
            If the <paramref name="symbol"/> is a type symbol, returns True if that type is "awaitable".
            An "awaitable" is any type that exposes a GetAwaiter method which returns a valid "awaiter". This GetAwaiter method may be an instance method or an extension method.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolExtensions.RemoveOverriddenSymbolsWithinSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            First, remove symbols from the set if they are overridden by other symbols in the set.
            If a symbol is overridden only by symbols outside of the set, then it is not removed. 
            This is useful for filtering out symbols that cannot be accessed in a given context due
            to the existence of overriding members. Second, remove remaining symbols that are
            unsupported (e.g. pointer types in VB) or not editor browsable based on the EditorBrowsable
            attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SymbolKey.Create(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            <para>
            This entry point should only be called from the actual Symbol classes. It should not be
            used internally inside this type.  Instead, any time we need to get the <see cref="T:ICSharpCode.NRefactory6.CSharp.SymbolKey"/> for a
            related symbol (i.e. the containing namespace of a namespace) we should call
            <see cref="!:GetOrCreate"/>.  The benefit of this is twofold.  First of all, it keeps the size of the
            <see cref="T:ICSharpCode.NRefactory6.CSharp.SymbolKey"/> small by allowing up to reuse parts we've already created.  For example, if we
            have the <see cref="T:ICSharpCode.NRefactory6.CSharp.SymbolKey"/> for <c>Foo(int, int)</c>, then we will reuse the <see cref="T:ICSharpCode.NRefactory6.CSharp.SymbolKey"/>s for both <c>int</c>s.
            Second, this allows us to deal with the recursive nature of MethodSymbols and
            TypeParameterSymbols.  Specifically, a MethodSymbol is defined by its signature.  However,
            it's signature may refer to type parameters of that method.  Unfortunately, the type
            parameters depend on their containing method.
            </para>
            <para>
            For example, if there is <c><![CDATA[Foo<T>(T t)]]></c>, then we must avoid the situation where we:
            <list type="number">
            <item>try to get the symbol ID for the type parameter <c>T</c>, which in turn</item>
            <item>tries to get the symbol ID for the method <c>T</c>, which in turn</item>
            <item>tries to get the symbol IDs for the parameter types, which in turn</item>
            <item>tries to get the symbol ID for the type parameter <c>T</c>, which leads back to 1 and infinitely loops.</item>
            </list>
            </para>
            <para>
            In order to break this circularity we do not create the SymbolIDs for a method's type
            parameters directly in the visitor.  Instead, we create the SymbolID for the method
            itself.  When the MethodSymbolId is created it will directly instantiate the SymbolIDs
            for the type parameters, and directly assign the type parameter's method ID to itself.
            It will also then directly store the mapping from the type parameter to its SymbolID in
            the visitor cache.  Then when we try to create the symbol IDs for the parameter types,
            any reference to the type parameters can be found in the cache.
            </para>
            <para>
            It is for this reason that it is essential that all calls to get related symbol IDs goes
            through GetOrCreate and not Create.
            </para>
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.SyntaxExtensions.s_findSkippedTokenBackward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxExtensions.GetSkippedTokens(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            return only skipped tokens
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.IsChildNode``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if is a given token is a child token of of a certain type of parent node.
            </summary>
            <typeparam name="TParent">The type of the parent node.</typeparam>
            <param name="node">The node that we are testing.</param>
            <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.IsFoundUnder``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if this node is found underneath the specified child in the given parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the tokens
            
            tokens should belong to the given root
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the nodes
            
            nodes should belong to the given root
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.ReplaceNodesAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of nodes from the existing tree with the specified old nodes replaced with a newly computed nodes.
            </summary>
            <param name="root">The root of the tree that contains all the specified nodes.</param>
            <param name="nodes">The nodes from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement node for
            the argument nodes. The first argument is one of the original specified nodes. The second argument is
            the same node possibly rewritten with replaced descendants.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.GetEnclosingUsingDirectives(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the list of using directives that affect <paramref name="node"/>. The list will be returned in
            top down order.  
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.GetAllPrecedingTriviaToPreviousToken(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns all of the trivia to the left of this token up to the previous token (concatenates
            the previous token's trailing trivia and this token's leading trivia).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Returns true if the passed in node contains an interleaved pp directive.
            
            i.e. The following returns false:
            
              void Foo() {
            #if true
            #endif
              }
            
            #if true
              void Foo() {
              }
            #endif
            
            but these return true:
            
            #if true
              void Foo() {
            #endif
              }
            
              void Foo() {
            #if true
              }
            #endif
            
            #if true
              void Foo() {
            #else
              }
            #endif
            
            i.e. the method returns true if it contains a PP directive that belongs to a grouping
            constructs (like #if/#endif or #region/#endregion), but the grouping construct isn't
            entirely contained within the span of the node.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.s_findSkippedTokenForward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.s_findSkippedTokenBackward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.GetSkippedTokens(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            return only skipped tokens
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxNodeExtensions.ChildThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32@)">
            <summary>
            Returns child node or token that contains given position.
            </summary>
            <remarks>
            This is a copy of <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/> that also returns the index of the child node.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxTokenExtensions.IsFirstTokenOnLine(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Determines whether the given SyntaxToken is the first token on a line in the specified SourceText.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxTokenExtensions.GetAllTrailingTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Retrieves all trivia after this token, including it's trailing trivia and
            the leading trivia of the next token.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxTokenExtensions.FindLastTokenOfPartialGenericName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Lexically, find the last token that looks like it's part of this generic name.
            </summary>
            <param name="genericIdentifier">The "name" of the generic identifier, last token before
            the "&amp;"</param>
            <returns>The last token in the name</returns>
            <remarks>This is related to the code in <see cref="M:ICSharpCode.NRefactory6.CSharp.SyntaxTreeExtensions.IsInPartiallyWrittenGeneric(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)"/></remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxTreeExtensions.IsHiddenPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if the provided position is in a hidden region inaccessible to the user.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.SyntaxTreeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextLineExtensions.GetFirstNonWhitespacePosition(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line, or null if 
            the line is empty or contains only whitespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextLineExtensions.GetFirstNonWhitespaceOffset(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line as an offset
            from the start of the line, or null if the line is empty or contains only
            whitespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TextLineExtensions.IsEmptyOrWhitespace(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Determines whether the specified line is empty or contains whitespace only.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetDelegateInvokeMethod(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Gets the invoke method for a delegate type.
            </summary>
            <remarks>
            Returns null if the type is not a delegate type; or if the invoke method could not be found.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetFullName(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Gets the full name of the namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetFullName(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Gets the full name. The full name is no 1:1 representation of a type it's missing generics and it has a poor
            representation for inner types (just dot separated).
            DO NOT use this method unless you're know what you do. It's only implemented for legacy code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.IsToolboxItem(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns true if the type is public and was tagged with
            [System.ComponentModel.ToolboxItem (true)]
            </summary>
            <returns><c>true</c> if is designer browsable the specified symbol; otherwise, <c>false</c>.</returns>
            <param name="symbol">Symbol.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetAllBaseClasses(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean)">
            <summary>
            Gets all base classes.
            </summary>
            <returns>The all base classes.</returns>
            <param name="type">Type.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetAllBaseClassesAndInterfaces(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean)">
            <summary>
            Gets all base classes and interfaces.
            </summary>
            <returns>All classes and interfaces.</returns>
            <param name="type">Type.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.IsDerivedFromClass(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determines if derived from baseType. Includes itself and all base classes, but does not include interfaces.
            </summary>
            <returns><c>true</c> if is derived from class the specified type baseType; otherwise, <c>false</c>.</returns>
            <param name="type">Type.</param>
            <param name="baseType">Base type.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.IsDerivedFromClassOrInterface(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determines if derived from baseType. Includes itself, all base classes and all interfaces.
            </summary>
            <returns><c>true</c> if is derived from the specified type baseType; otherwise, <c>false</c>.</returns>
            <param name="type">Type.</param>
            <param name="baseType">Base type.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetFullMetadataName(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Gets the full name of the metadata.
            In case symbol is not INamedTypeSymbol it returns raw MetadataName
            Example: Generic type returns T1, T2...
            </summary>
            <returns>The full metadata name.</returns>
            <param name="symbol">Symbol.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeExtensions.GetFullMetadataName(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets the full MetadataName(ReflectionName in NR5).
            Example: Namespace1.Namespace2.Classs1+NestedClassWithTwoGenericTypes`2+NestedClassWithoutGenerics
            </summary>
            <returns>The full metadata name.</returns>
            <param name="symbol">Symbol.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.TypeSyntaxExtensions.IsTypeInferred(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Determines whether the specified TypeSyntax is actually 'var'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.CSharp.Refactoring.CodeRefactoring">
            <summary>
            Represents a set of transformations that can be applied to a piece of code.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.CSharp.Refactoring.CodeRefactoring.Actions">
            <summary>
            List of possible actions that can be used to transform the code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.AddMethod``1(``0,Microsoft.CodeAnalysis.IMethodSymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a method into destination.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CreateEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationDestination)" -->
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CreateFieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationDestination)">
            <summary>
            Returns a newly created field declaration node from the provided field.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CreateMethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationDestination)">
            <summary>
            Returns a newly created method declaration node from the provided method.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CreatePropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationDestination)">
            <summary>
            Returns a newly created property declaration node from the provided property.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CreateNamedTypeDeclaration(Microsoft.CodeAnalysis.INamedTypeSymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationDestination)">
            <summary>
            Returns a newly created named type declaration node from the provided named type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CreateNamespaceDeclaration(Microsoft.CodeAnalysis.INamespaceSymbol,ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationDestination)">
            <summary>
            Returns a newly created namespace declaration node from the provided namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.AddMembersAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},ICSharpCode.NRefactory6.CSharp.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds all the provided members into destination.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.CSharp.CodeGeneration.CSharpCodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.Utils.BinaryReaderWith7BitEncodedInts">
            <summary>
            A binary reader that can read the output of BinaryWriterWith7BitEncodedInts.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.Utils.BinaryWriterWith7BitEncodedInts">
            <summary>
            A binary writer that encodes all integers as 7-bit-encoded-ints.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.Utils.FastSerializer.SerializationBinder">
            <summary>
            Gets/Sets the serialization binder that is being used.
            The default value is null, which will cause the FastSerializer to use the
            full assembly and type names.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory6.Utils.FastSerializer.FixedInstances">
            <summary>
            Can be used to set several 'fixed' instances.
            When serializing, such instances will not be included; and any references to a fixed instance
            will be stored as the index in this array.
            When deserializing, the same (or equivalent) instances must be specified, and the deserializer
            will use them in place of the fixed instances.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.SerializationContext.Mark(System.Object)">
            <summary>
            Marks an instance for future scanning.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.EmitScanField(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Reflection.FieldInfo)">
            <summary>
            Emit 'scan instance.Field'.
            Stack transition: ... => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.EmitScanValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Stack transition: ..., value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.EmitWriteField(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Reflection.Emit.LocalBuilder,System.Reflection.FieldInfo)">
            <summary>
            Emit 'write instance.Field'.
            Stack transition: ... => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.WritePrimitiveValue(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Writes a primitive value of the specified type.
            Stack transition: ..., writer, value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.EmitWriteValueType(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Stack transition: ..., value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.ReadPrimitiveValue(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Reads a primitive value of the specified type.
            Stack transition: ... => ..., value
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.Utils.FastSerializer.EmitReadValueType(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Stack transition: ..., field-ref => ...
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.Utils.FastSerializerVersionAttribute">
            <summary>
            Specifies the version of the class.
            The <see cref="T:ICSharpCode.NRefactory6.Utils.FastSerializer"/> will refuse to deserialize an instance that was stored by
            a different version of the class than the current one.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.LF">
            <summary>
            Line Feed, U+000A
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.CR">
            <summary>
            Carriage Return, U+000D
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.NEL">
            <summary>
            Next Line, U+0085
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.VT">
            <summary>
            Vertical Tab, U+000B
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.FF">
            <summary>
            Form Feed, U+000C
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.LS">
            <summary>
            Line Separator, U+2028
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.UnicodeNewline.PS">
            <summary>
            Paragraph Separator, U+2029
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory6.NewLine">
            <summary>
            Defines unicode new lines according to  Unicode Technical Report #13
            http://www.unicode.org/standard/reports/tr13/tr13-5.html
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.CR">
            <summary>
            Carriage Return, U+000D
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.LF">
            <summary>
            Line Feed, U+000A
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.NEL">
            <summary>
            Next Line, U+0085
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.VT">
            <summary>
            Vertical Tab, U+000B
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.FF">
            <summary>
            Form Feed, U+000C
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.LS">
            <summary>
            Line Separator, U+2028
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory6.NewLine.PS">
            <summary>
            Paragraph Separator, U+2029
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.GetDelimiterLength(System.Char,System.Func{System.Char})">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">A callback getting the next character (may be null).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.GetDelimiterLength(System.Char,System.Char)">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">The next character (if != LF then length will always be 0 or 1).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.TryGetDelimiterLengthAndType(System.Char,System.Int32@,ICSharpCode.NRefactory6.UnicodeNewline@,System.Func{System.Char})">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name = "length">The length of the delimiter</param>
            <param name = "type">The type of the delimiter</param>
            <param name="nextChar">A callback getting the next character (may be null).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.TryGetDelimiterLengthAndType(System.Char,System.Int32@,ICSharpCode.NRefactory6.UnicodeNewline@,System.Char)">
            <summary>
            Determines if a char is a new line delimiter.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name = "length">The length of the delimiter</param>
            <param name = "type">The type of the delimiter</param>
            <param name="nextChar">The next character (if != LF then length will always be 0 or 1).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.GetDelimiterType(System.Char,System.Func{System.Char})">
            <summary>
            Gets the new line type of a given char/next char.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">A callback getting the next character (may be null).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.GetDelimiterType(System.Char,System.Char)">
            <summary>
            Gets the new line type of a given char/next char.
            </summary>
            <returns>0 == no new line, otherwise it returns either 1 or 2 depending of the length of the delimiter.</returns>
            <param name="curChar">The current character.</param>
            <param name="nextChar">The next character (if != LF then length will always be 0 or 1).</param>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.IsNewLine(System.Char)">
            <summary>
            Determines if a char is a new line delimiter. 
            
            Note that the only 2 char wide new line is CR LF and both chars are new line
            chars on their own. For most cases GetDelimiterLength is the better choice.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory6.NewLine.GetString(ICSharpCode.NRefactory6.UnicodeNewline)">
            <summary>
            Gets the new line as a string.
            </summary>
        </member>
    </members>
</doc>
